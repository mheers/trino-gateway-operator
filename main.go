package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/workqueue"
)

// TrinoBackend is the CRD structure
type TrinoBackend struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TrinoBackendSpec `json:"spec"`
}

// TrinoBackendSpec defines the desired state of TrinoBackend
type TrinoBackendSpec struct {
	Name         string `json:"name"`
	ProxyTo      string `json:"proxyTo"`
	Active       bool   `json:"active"`
	RoutingGroup string `json:"routingGroup"`
	ExternalUrl  string `json:"externalUrl,omitempty"`
}

// TrinoBackendList contains a list of TrinoBackend
type TrinoBackendList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrinoBackend `json:"items"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TrinoBackend) DeepCopyInto(out *TrinoBackend) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TrinoBackend.
func (in *TrinoBackend) DeepCopy() *TrinoBackend {
	if in == nil {
		return nil
	}
	out := new(TrinoBackend)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TrinoBackend) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TrinoBackendList) DeepCopyInto(out *TrinoBackendList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]TrinoBackend, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TrinoBackendList.
func (in *TrinoBackendList) DeepCopy() *TrinoBackendList {
	if in == nil {
		return nil
	}
	out := new(TrinoBackendList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TrinoBackendList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

var (
	SchemeGroupVersion = schema.GroupVersion{Group: "trino.example.com", Version: "v1"}
	SchemeBuilder      = runtime.NewSchemeBuilder(addKnownTypes)
	AddToScheme        = SchemeBuilder.AddToScheme
)

func addKnownTypes(scheme *runtime.Scheme) error {
	scheme.AddKnownTypes(SchemeGroupVersion,
		&TrinoBackend{},
		&TrinoBackendList{},
	)
	metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
	return nil
}

var (
	myScheme = runtime.NewScheme()
)

func init() {
	_ = AddToScheme(myScheme)
	_ = scheme.AddToScheme(myScheme)
}

func getClientConfig() (*rest.Config, error) {
	// Try in-cluster config first
	config, err := rest.InClusterConfig()
	if err == nil {
		return config, nil
	}

	// If in-cluster config fails, try kubeconfig file
	kubeconfigPath := os.Getenv("KUBECONFIG")
	if kubeconfigPath == "" {
		// If KUBECONFIG is not set, use the default path
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return nil, fmt.Errorf("failed to get user home directory: %v", err)
		}
		kubeconfigPath = filepath.Join(homeDir, ".kube", "config")
	}

	// Use the current context in kubeconfig
	config, err = clientcmd.BuildConfigFromFlags("", kubeconfigPath)
	if err != nil {
		return nil, fmt.Errorf("failed to build config from kubeconfig: %v", err)
	}

	return config, nil
}

func main() {
	// Set up Kubernetes client configuration
	config, err := getClientConfig()
	if err != nil {
		panic(fmt.Sprintf("Failed to get Kubernetes config: %v", err))
	}

	// Create a dynamic client
	dynamicClient, err := dynamic.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	// Create a new RESTClient for our custom resources
	crdConfig := *config
	crdConfig.GroupVersion = &SchemeGroupVersion
	crdConfig.APIPath = "/apis"
	// crdConfig.NegotiatedSerializer = serializer.NewCodecFactory(myScheme)
	crdConfig.NegotiatedSerializer = scheme.Codecs.WithoutConversion()

	crdConfig.UserAgent = rest.DefaultKubernetesUserAgent()
	// Define the GroupVersionResource
	gvr := SchemeGroupVersion.WithResource("trinobackends")

	// Create a new queue
	queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())

	// Create custom ListFunc and WatchFunc
	listFunc := func(options metav1.ListOptions) (runtime.Object, error) {
		return dynamicClient.Resource(gvr).Namespace(metav1.NamespaceAll).List(context.TODO(), options)
	}

	watchFunc := func(options metav1.ListOptions) (watch.Interface, error) {
		return dynamicClient.Resource(gvr).Namespace(metav1.NamespaceAll).Watch(context.TODO(), options)
	}

	// Create a new informer
	indexInformer := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc:  listFunc,
			WatchFunc: watchFunc,
		},
		&unstructured.Unstructured{},
		0, // resync period
		cache.Indexers{},
	)

	indexInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			key, err := cache.MetaNamespaceKeyFunc(obj)
			if err == nil {
				queue.Add(key)
			}
		},
		UpdateFunc: func(old interface{}, new interface{}) {
			key, err := cache.MetaNamespaceKeyFunc(new)
			if err == nil {
				queue.Add(key)
			}
		},
		DeleteFunc: func(obj interface{}) {
			key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
			if err == nil {
				queue.Add(key)
			}
		},
	})

	// Start the controller
	stop := make(chan struct{})
	defer close(stop)
	go indexInformer.Run(stop)

	// Start the queue processing
	for {
		key, quit := queue.Get()
		if quit {
			return
		}
		err := processItem(key.(string), dynamicClient)
		if err != nil {
			fmt.Printf("Error processing item: %v\n", err)
		}
		queue.Done(key)
	}

}

const (
	gatewayAPIBaseURL = "http://localhost:8080" // Replace with your Trino Gateway API URL
	gatewayUsername   = "your_username"         // Replace with your actual username
	gatewayPassword   = "your_password"         // Replace with your actual password
)

func createHTTPClientWithBasicAuth() *http.Client {
	return &http.Client{
		Timeout:   10 * time.Second,
		Transport: &http.Transport{
			// You can add more customizations here if needed
		},
	}
}

func addBasicAuth(req *http.Request) {
	req.SetBasicAuth(gatewayUsername, gatewayPassword)
}

func createOrUpdateBackend(backend TrinoBackend) error {
	url := fmt.Sprintf("%s/entity?entityType=GATEWAY_BACKEND", gatewayAPIBaseURL)

	payload := map[string]interface{}{
		"name":         backend.Spec.Name,
		"proxyTo":      backend.Spec.ProxyTo,
		"active":       backend.Spec.Active,
		"routingGroup": backend.Spec.RoutingGroup,
	}
	if backend.Spec.ExternalUrl != "" {
		payload["externalUrl"] = backend.Spec.ExternalUrl
	}

	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal backend payload: %v", err)
	}

	req, err := http.NewRequest("POST", url, strings.NewReader(string(jsonPayload)))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")
	addBasicAuth(req)

	client := createHTTPClientWithBasicAuth()
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("failed to create/update backend, status code: %d, body: %s", resp.StatusCode, string(body))
	}

	return nil
}

func deleteBackend(name string) error {
	url := fmt.Sprintf("%s/gateway/backend/modify/delete", gatewayAPIBaseURL)

	req, err := http.NewRequest("POST", url, strings.NewReader(name))
	if err != nil {
		return fmt.Errorf("failed to create delete request: %v", err)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	addBasicAuth(req)

	client := createHTTPClientWithBasicAuth()
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send delete request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("failed to delete backend, status code: %d, body: %s", resp.StatusCode, string(body))
	}

	return nil
}

func processItem(key string, dynamicClient dynamic.Interface) error {
	namespace, name, err := cache.SplitMetaNamespaceKey(key)
	if err != nil {
		return fmt.Errorf("invalid resource key: %s", key)
	}

	// Get the TrinoBackend resource
	gvr := SchemeGroupVersion.WithResource("trinobackends")
	unstructured, err := dynamicClient.Resource(gvr).Namespace(namespace).Get(context.TODO(), name, metav1.GetOptions{})
	if err != nil {
		return fmt.Errorf("failed to get TrinoBackend: %v", err)
	}

	var backend TrinoBackend
	err = runtime.DefaultUnstructuredConverter.FromUnstructured(unstructured.UnstructuredContent(), &backend)
	if err != nil {
		return fmt.Errorf("failed to convert unstructured to TrinoBackend: %v", err)
	}

	// Process the TrinoBackend based on its state
	if backend.ObjectMeta.DeletionTimestamp != nil {
		// The resource is being deleted
		return deleteBackend(backend.Spec.Name)
	}

	// The resource is being created or updated
	return createOrUpdateBackend(backend)
}
